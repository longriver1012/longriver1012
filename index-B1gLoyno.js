import{bM as b,r as x,j as K}from"./index-Bb-7Eb0M.js";import{u as D}from"./useSize-C_rNTEhI.js";class S{constructor(t){this.editor=t}draw(){this.drawXYGrid(!0),this.drawXYGrid(!1)}drawXYGrid(t){const s=this.getParams(t);if(!s)return;let e=s.pos,i=0;for(;;){const o=e*s.space,n=t?this.editor.mapLogicalToCanvasX(o):this.editor.mapLogicalToCanvasY(o);if((t?n>this.editor.canvas.width:n<0)||(this.drawLine(e,n,t),this.drawLabel(n,o,s.decPow,t),e+=s.span,i++>100))break}}getParams(t){const s=t?60:40,e=t?this.editor.xMin:this.editor.yMin,i=s/this.editor.getZoomFactor(t),o=Math.ceil(Math.log(i/5)/Math.LN10);if((e==0?-99:Math.log(Math.abs(e))/Math.LN10)-o>10)return;const a=Math.pow(10,o),r=i/a,h=r>2.001?5:r>1.001?2:1,d=Math.ceil(e/a),v=h*Math.ceil(d/h);return{space:a,span:h,pos:v,decPow:o}}drawLine(t,s,e){const{canvas:i,context:o}=this.editor;o.save(),o.fillStyle=t==0?"#000":(t%10==0,"#6f6f6f"),o.fillRect(e?s:0,e?0:s,e?1:i.width,e?i.height:1),o.restore()}drawLabel(t,s,e,i){const{canvas:o,context:n}=this.editor;n.save(),n.textBaseline="bottom",n.font="12px",n.fillStyle="#fafafa";const a=i?t+5:5,r=i?o.height-2:t-2,h=this.formatLabel(s,e);n.fillText(h,a,r),n.restore()}formatLabel(t,s){let e=s<=7&&s>=-6?t.toFixed(Math.max(0,-s)):t.toExponential();return e.length>10&&(e=t.toPrecision(6)),e}}function P(c){let t=String(c);return t.length>10&&(t=c.toPrecision(6)),t}Promise.resolve();class g{static clone(t){return{x:t.x,y:t.y}}static computeDistance(t,s){const e=t.x-s.x,i=t.y-s.y;return Math.sqrt(e*e+i*i)}static computeCenter(t,s){return{x:(t.x+s.x)/2,y:(t.y+s.y)/2}}static mapPointIndex(t,s,e){if(e==null)return;const i=t[e];return g.findPoint(s,i)}static findPoint(t,s){if(!s)return;const e=t.indexOf(s);return e>=0?e:void 0}static makeXValsStrictMonotonic(t){for(let s=1;s<t.length;s++)t[s].x<=t[s-1].x&&(t[s].x=t[s-1].x+1e-6)}static dumpPoints(t){for(let s=0;s<t.length;s++)console.log("["+s+"] = ("+t[s].x+", "+t[s].y+")")}static encodeCoordinateList(t){let s="";for(const e of t)s.length>0&&(s+=", "),s+="["+P(e.x)+", "+P(e.y)+"]";return s}static decodeCoordinateList(t){const s=JSON.parse("["+t+"]"),e=Array(s.length);for(let i=0;i<s.length;i++){const o=s[i];if(!Array.isArray(o)||o.length!=2||typeof o[0]!="number"||typeof o[1]!="number")throw new Error("Invalid syntax in element "+i+".");e[i]={x:o[0],y:o[1]}}return e}}class E{constructor(t){this.zooming=!1,this.onPointerdown=s=>{const{altKey:e,ctrlKey:i,shiftKey:o,metaKey:n,pointerType:a,button:r}=s;if(!(e||i||n||o||a=="mouse"&&r!=0)){if(this.trackPointer(s),(a=="touch"||a=="pen")&&this.pointers.size==1){if(this.lastTouchTime>0&&performance.now()-this.lastTouchTime<=300){this.lastTouchTime=0,this.processDoubleClickTouch(),s.preventDefault();return}this.lastTouchTime=performance.now()}this.switchMode(),s.preventDefault()}},this.onPointerUp=s=>{this.pointers.has(s.pointerId)&&(this.releasePointer(s.pointerId),this.switchMode(),s.preventDefault())},this.onPointerMove=s=>{if(!this.pointers.has(s.pointerId)){this.updatePotentialKnot(s);return}this.trackPointer(s),this.pointers.size==1?this.drag():this.pointers.size==2&&this.zooming&&this.zoom(),s.preventDefault()},this.onDoubleClick=s=>{const{altKey:e,ctrlKey:i,shiftKey:o,metaKey:n,button:a}=s;if(e||i||n||o||a!=0)return;const r=this.getCanvasCoordinatesFromEvent(s);this.createKnot(r),s.preventDefault()},this.onWheel=s=>{s.preventDefault();const e=s.deltaMode==0&&Math.abs(s.deltaY)<50||s.deltaX!=0;if(e&&!s.ctrlKey){this.moveByWheel(s);return}if(s.deltaY==0)return;const i=e?1.05:Math.SQRT2,o=s.deltaY>0?1/i:i;let n;s.shiftKey?n=p.y:s.altKey?n=p.x:s.ctrlKey&&!e?n=p.xy:n=this.editor.primaryZoomMode;let a,r;switch(n){case p.x:{a=o,r=1;break}case p.y:{a=1,r=o;break}default:a=o,r=o}const h=this.getCanvasCoordinatesFromEvent(s);this.editor.zoom(a,r,h),this.editor.refresh()},this.editor=t,this.pointers=new Map,this.dragCount=0,this.lastTouchTime=0,this.zoomLCenter={x:0,y:0},this.zoomStartDist=0,this.zoomStartFactorX=0,this.zoomStartFactorY=0,this.zoomX=!1,this.zoomY=!1,t.canvas.addEventListener("pointerdown",this.onPointerdown),t.canvas.addEventListener("pointerup",this.onPointerUp),t.canvas.addEventListener("pointercancel",this.onPointerUp),t.canvas.addEventListener("pointermove",this.onPointerMove),t.canvas.addEventListener("dblclick",this.onDoubleClick),t.canvas.addEventListener("wheel",this.onWheel)}get canvas(){return this.editor.canvas}trackPointer(t){const s=t.pointerId;this.pointers.has(s)||this.canvas.setPointerCapture(s),this.pointers.set(s,t)}releaseAllPointers(){for(;this.pointers.size>0;){const t=this.pointers.keys().next().value;t&&this.releasePointer(t)}}releasePointer(t){this.pointers.delete(t),this.canvas.releasePointerCapture(t)}processDoubleClickTouch(){const t=this.getCanvasCoordinates();this.createKnot(t)}getCanvasCoordinates(){if(this.pointers.size<1)throw new Error("No active pointers.");const t=this.pointers.values().next().value;return this.getCanvasCoordinatesFromEvent(t)}getCanvasCoordinatesFromEvent(t){return this.editor.mapViewportToCanvasCoordinates({x:t.clientX,y:t.clientY})}switchMode(){this.stopDragging(),this.stopZooming(),this.pointers.size==1?(this.startDragging(),this.canvas.focus()):this.pointers.size==2&&this.startZooming()}stopDragging(){(this.editor.knotDragging||this.editor.planeDragging)&&this.editor.refresh(),this.dragStartLPos=void 0,this.dragStartCPos=void 0,this.editor.knotDragging=!1,this.editor.planeDragging=!1}stopZooming(){this.zooming=!1}startDragging(){const t=this.getCanvasCoordinates(),s=this.editor.mapCanvasToLogicalCoordinates(t),e=this.pointers.values().next().value.pointerType,i=this.findNearKnot(t,e);this.editor.currentKnot=i,this.editor.knotDragging=i!=null,this.editor.planeDragging=i==null,this.dragStartLPos=s,this.dragStartCPos=t,this.dragCount=0,this.editor.refresh()}startZooming(){const t=this.pointers.values(),s=t.next().value,e=t.next().value,i=this.getCanvasCoordinatesFromEvent(s),o=this.getCanvasCoordinatesFromEvent(e),n=g.computeCenter(i,o),a=Math.abs(i.x-o.x),r=Math.abs(i.y-o.y);this.zoomLCenter=this.editor.mapCanvasToLogicalCoordinates(n),this.zoomStartDist=g.computeDistance(i,o),this.zoomStartFactorX=this.editor.getZoomFactor(!0),this.zoomStartFactorY=this.editor.getZoomFactor(!1);const h=Math.tan(Math.PI/8);this.zoomX=a>h*r,this.zoomY=r>h*a,this.zooming=!0}drag(){const t=this.getCanvasCoordinates();if(this.editor.knotDragging&&this.editor.currentKnot!=null){const s=this.editor.mapCanvasToLogicalCoordinates(t);this.editor.moveKnot(this.editor.currentKnot,s),this.editor.refresh()}else this.editor.planeDragging&&this.dragStartLPos&&(this.editor.moveCoordinatePlane(t,this.dragStartLPos),this.editor.refresh())}zoom(){const t=this.pointers.values(),s=t.next().value,e=t.next().value,i=this.getCanvasCoordinatesFromEvent(s),o=this.getCanvasCoordinatesFromEvent(e),n=g.computeCenter(i,o),r=g.computeDistance(i,o)/this.zoomStartDist;this.zoomX&&(this.editor.xMax=this.editor.xMin+this.canvas.width/(this.zoomStartFactorX*r)),this.zoomY&&(this.editor.yMax=this.editor.yMin+this.canvas.height/(this.zoomStartFactorY*r)),this.editor.moveCoordinatePlane(n,this.zoomLCenter),this.editor.refresh()}moveByWheel(t){const s=t.deltaMode==1?15:t.deltaMode==2?100:1,e=s*t.deltaX,i=s*t.deltaY;e==0&&i==0||(this.editor.moveCoordinatePlaneRelPx(e,-i),this.editor.refresh())}updatePotentialKnot(t){const s=this.getCanvasCoordinatesFromEvent(t),e=this.findNearKnot(s,t.pointerType);this.editor.potentialKnot!=e&&(this.editor.potentialKnot=e,this.editor.refresh())}findNearKnot(t,s){const e=this.editor.findNearestKnot(t),i=s=="touch"?30:15;return e&&e.distance<=i?e.knot:void 0}createKnot(t){const s=this.editor.mapCanvasToLogicalCoordinates(t);this.editor.addKnot(s),this.editor.refresh()}dispose(){this.canvas.removeEventListener("pointerdown",this.onPointerdown),this.canvas.removeEventListener("pointerup",this.onPointerUp),this.canvas.removeEventListener("pointercancel",this.onPointerUp),this.canvas.removeEventListener("pointermove",this.onPointerMove),this.canvas.removeEventListener("dblclick",this.onDoubleClick),this.canvas.removeEventListener("wheel",this.onWheel),this.releaseAllPointers()}}class w{constructor(t,s,e,i,o){this.editor=t,this.v0=s,this.v1=e,this.v2=i,this.v3=o}draw(){this.drawLine(),this.drawConnections(),this.drawKnot(this.v0,"end"),this.drawKnot(this.v3,"end"),this.drawKnot(this.v1,"control"),this.drawKnot(this.v2,"control")}drawLine(){const{context:t}=this.editor,{v0:s,v1:e,v2:i,v3:o}=this,n=this.editor.mapLogicalToCanvasCoordinates(s),a=this.editor.mapLogicalToCanvasCoordinates(e),r=this.editor.mapLogicalToCanvasCoordinates(i),h=this.editor.mapLogicalToCanvasCoordinates(o);t.save(),t.beginPath(),t.strokeStyle="#ff9500",t.lineWidth=2,t.moveTo(n.x,n.y),t.bezierCurveTo(a.x,a.y,r.x,r.y,h.x,h.y),t.stroke(),t.restore()}drawKnot(t,s){const{context:e,potentialKnot:i}=this.editor,o=i==t;e.save(),e.beginPath();const n=this.editor.mapLogicalToCanvasCoordinates(t);s==="end"?(e.fillStyle=o?"#ff9500":"#ff3b30",e.arc(n.x,n.y,4,0,Math.PI*2)):s==="control"&&(e.fillStyle=o?"#ff9500":"#007aff",e.arc(n.x,n.y,4,0,Math.PI*2)),e.fill(),s==="control"&&(e.beginPath(),e.arc(n.x,n.y,4,0,Math.PI*2),e.strokeStyle="rgba(255, 255, 255, 0.8)",e.lineWidth=1.5,e.stroke()),o&&(e.fillStyle="white",e.font="12px Arial",e.textAlign="center",e.fillText(`(${t.x.toFixed(2)}, ${t.y.toFixed(2)})`,n.x,n.y+20)),e.restore()}drawConnections(){const{context:t}=this.editor,{v0:s,v1:e,v2:i,v3:o}=this,n=this.editor.mapLogicalToCanvasCoordinates(s),a=this.editor.mapLogicalToCanvasCoordinates(e),r=this.editor.mapLogicalToCanvasCoordinates(i),h=this.editor.mapLogicalToCanvasCoordinates(o);t.save(),t.beginPath(),t.strokeStyle="rgba(100, 100, 100, 0.5)",t.lineWidth=1,t.moveTo(n.x,n.y),t.lineTo(a.x,a.y),t.moveTo(r.x,r.y),t.lineTo(h.x,h.y),t.stroke(),t.restore()}serialize(){const{v0:t,v1:s,v2:e,v3:i}=this;return{v0:[t.x,t.y],v1:[s.x,s.y],v2:[e.x,e.y],v3:[i.x,i.y]}}}class k{constructor(t,s){this.id=b(),this.x=t,this.y=s}}class f extends k{constructor(t,s){super(t,s)}}class l extends k{constructor(t,s,e){super(t,s),this.end=e}}var p=(c=>(c[c.x=0]="x",c[c.y=1]="y",c[c.xy=2]="xy",c))(p||{});function u(c){return c?parseFloat(c):0}class z{constructor(t){this.render=()=>{this.playing=!1,(this.width!=this.canvas.width||this.height!=this.canvas.height)&&(this.canvas.width=this.width,this.canvas.height=this.height),this.canvas.style.cursor=this.knotDragging||this.planeDragging?"move":"auto",this.clear(),this.grid.draw(),this.curves.forEach(s=>s.draw())},this.canvas=t,this.context=t.getContext("2d"),this.canvasStyle=getComputedStyle(t),this.playing=!1,this.primaryZoomMode=2,this.xMin=0,this.xMax=1,this.yMin=0,this.yMax=1,this.knotDragging=!1,this.planeDragging=!1,this.width=this.canvas.width,this.height=this.canvas.height,this.knots=[],this.curves=[],this.pointerController=new E(this),this.grid=new S(this)}resize(t,s){this.width=t,this.height=s,this.refresh()}refresh(){this.playing||(requestAnimationFrame(this.render),this.playing=!0)}clear(){this.context.save();const t=this.canvas.width,s=this.canvas.height;this.context.fillStyle="#303035",this.context.fillRect(0,0,t,s),this.context.restore()}setCurves(t){this.knots=[],this.curves=[];for(let s=0;s<t.length;s++){const{v0:e,v1:i,v2:o,v3:n}=t[s];if(s===0){const a=new f(e[0],e[1]),r=new f(n[0],n[1]),h=new l(i[0],i[1],a),d=new l(o[0],o[1],r);a.after=h,r.before=d,this.knots.push(a,h,d,r),this.curves.push(new w(this,a,h,d,r))}else{const a=this.knots[this.knots.length-1],r=new f(n[0],n[1]),h=new l(i[0],i[1],a),d=new l(o[0],o[1],r);a.after=h,r.before=d,this.knots.push(h,d,r),this.curves.push(new w(this,a,h,d,r))}}this.refresh()}getCurves(){return this.curves.map(t=>t.serialize())}mapLogicalToCanvasX(t){return(t-this.xMin)*this.canvas.width/(this.xMax-this.xMin)}mapLogicalToCanvasY(t){return this.canvas.height-(t-this.yMin)*this.canvas.height/(this.yMax-this.yMin)}mapCanvasToLogicalX(t){return this.xMin+t*(this.xMax-this.xMin)/this.canvas.width}mapCanvasToLogicalY(t){return this.yMin+(this.canvas.height-t)*(this.yMax-this.yMin)/this.canvas.height}mapCanvasToLogicalCoordinates(t){return{x:this.mapCanvasToLogicalX(t.x),y:this.mapCanvasToLogicalY(t.y)}}mapLogicalToCanvasCoordinates(t){return{x:this.mapLogicalToCanvasX(t.x),y:this.mapLogicalToCanvasY(t.y)}}mapViewportToCanvasCoordinates(t){const s=this.canvasStyle,e=this.canvas.getBoundingClientRect(),i=u(s.paddingLeft),o=u(s.paddingRight),n=u(s.paddingTop),a=u(s.paddingBottom),r=u(s.borderLeftWidth),h=u(s.borderTopWidth),d=this.canvas.clientWidth-i-o,v=this.canvas.clientHeight-n-a,m=t.x-e.left-r-i,y=t.y-e.top-h-n,C=m/d*this.canvas.width,M=y/v*this.canvas.height;return{x:C,y:M}}moveCoordinatePlane(t,s){const{xMin:e,xMax:i,yMin:o,yMax:n}=this,a=i-e,r=n-o,h=this.canvas.width,d=this.canvas.height;this.xMin=s.x-t.x*a/h,this.xMax=this.xMin+a,this.yMin=s.y-(d-t.y)*r/d,this.yMax=this.yMin+r}getZoomFactor(t){const{xMax:s,xMin:e,yMax:i,yMin:o}=this;return t?this.canvas.width/(s-e):this.canvas.height/(i-o)}zoom(t,s,e){const i=s??t,o=e||{x:this.canvas.width/2,y:this.canvas.height/2},n=this.mapCanvasToLogicalCoordinates(o);this.xMax=this.xMin+(this.xMax-this.xMin)/t,this.yMax=this.yMin+(this.yMax-this.yMin)/i,this.moveCoordinatePlane(o,n)}moveCoordinatePlaneRelPx(t,s){const e=this.xMax-this.xMin,i=this.yMax-this.yMin,o=this.canvas.width,n=this.canvas.height;this.xMin=this.xMin+t/o*e,this.xMax=this.xMin+e,this.yMin=this.yMin+s/n*i,this.yMax=this.yMin+i}findNearestKnot(t){const s=this.knots;let e,i;for(let o=0;o<s.length;o++){const n=s[o],a=this.mapLogicalToCanvasCoordinates(n),r=g.computeDistance(a,t);(e==null||r<e)&&(i=o,e=r)}return i!=null?{knot:this.knots[i],distance:e}:void 0}addKnot(t){if(t.x<0||t.x>1)return;const s=.001,e=this.knots.filter(a=>a instanceof f).sort((a,r)=>a.x-r.x);for(let a=0;a<e.length;a++)e[a].x===t.x&&(t.x+=s);const i=new f(t.x,t.y);let o,n;for(let a=0;a<e.length;a++){const r=e[a];r.x<=t.x&&(o=r.x>=((o==null?void 0:o.x)??0)?r:o),r.x>=t.x&&(n=r.x<=((n==null?void 0:n.x)??1)?r:n)}if(o&&n){const a=this.curves.findIndex(r=>r.v0===o&&r.v3===n);if(a!=-1){const r=this.curves[a],h=r.v0,d=r.v1,v=r.v2,m=r.v3;d.x>=t.x&&(d.x=(h.x+t.x)*.5),v.x<=t.x&&(v.x=(t.x+m.x)*.5);const y=new l((h.x+t.x)*.5,t.y,i),C=new l((t.x+m.x)*.5,t.y,i);r.v2=y,r.v3=i,i.before=y,i.after=C;const M=new w(this,i,C,v,m);this.curves.splice(a+1,0,M),this.knots.push(y,i,C)}}else if(o){const a=new l((o.x+t.x)*.5,o.y,o);o.after=a;const r=new l((o.x+t.x)*.5,t.y,i);i.before=r;const h=new w(this,o,a,r,i);this.curves.push(h),this.knots.push(a,r,i)}else if(n){const a=new l((t.x+n.x)*.5,t.y,i);i.after=a;const r=new l((t.x+n.x)*.5,n.y,n);n.before=r;const h=new w(this,i,a,r,n);this.curves.unshift(h),this.knots.push(a,r,i)}this.refresh()}moveKnot(t,s){this.adaptPosition(t,s),t.x=s.x,t.y=s.y,this.refresh()}adaptPosition(t,s){let i=0,o=1;if(t instanceof f)for(let n=0;n<this.knots.length;n++){const a=this.knots[n];a.x<t.x&&(i=Math.max(i,a.x)),a.x>t.x&&(o=Math.min(o,a.x))}else{const n=this.knots.filter(a=>a instanceof f);for(let a=0;a<n.length;a++){const r=n[a];r.x<t.x&&(i=Math.max(i,r.x)),r.x>t.x&&(o=Math.min(o,r.x))}}s.x=Math.max(i+1e-6,Math.min(o-1e-6,s.x))}dispose(){this.pointerController.dispose()}}const L=800,T=400,X=x.forwardRef((c,t)=>{const{curves:s}=c,e=x.useRef(null),[i,o]=x.useState(),n=D(e);return x.useEffect(()=>{const a=new z(e.current);return o(a),()=>{a.dispose(),o(void 0)}},[]),x.useEffect(()=>{const{width:a,height:r}=n;i==null||i.resize(a,r)},[n,i]),x.useEffect(()=>{i==null||i.setCurves(s)},[s,i]),x.useImperativeHandle(t,()=>({getCurves:()=>(i==null?void 0:i.getCurves())??[]}),[i]),K.jsx("canvas",{ref:e,width:L,height:T,style:{width:L,height:T}})});export{X as CurveEditor};
